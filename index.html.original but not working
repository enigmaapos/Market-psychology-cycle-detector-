<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>1D Previous Doji Detector — Binance Futures USDT Perpetuals (Safe)</title>
  <style>
    body{font-family:Inter, Roboto, Arial; background:#0f1720; color:#e6eef8; margin:12px}
    .card{background:#0b1220;border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,0.5);max-width:1100px}
    label,input,button,select{font-size:14px}
    input,select{padding:6px;margin-right:6px;background:#071021;border:1px solid #172033;color:#d6e7ff;border-radius:6px}
    button{padding:8px 10px;border-radius:8px;border:none;background:#1f8cff;color:#fff;cursor:pointer}
    .log{background:#06121a;padding:8px;border-radius:6px;margin-top:10px;min-height:160px;overflow:auto}
    .result{padding:8px;border-radius:6px;margin-top:8px}
    .result.doji{background:#08331a;color:#a6f7be}
    .result.no{background:#3a0f0f;color:#ffbdbd}
    .row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
    .meta{margin-top:8px;color:#94a3b8;font-size:13px}
    .small{font-size:12px;color:#9fb5d6}
    .controls{margin-top:10px}
    .summary{margin-top:8px;color:#9fb5d6;font-size:13px}
  </style>
</head>
<body>
  <div class="card">
    <h2>1D Previous Doji Detector — Binance Futures (USDT Perps)</h2>

    <div class="row controls">
      <label>Batch size (symbols/request batch)</label>
      <input id="batchSize" value="30" style="width:80px" />

      <label>Concurrency (parallel REST batches)</label>
      <input id="concurrency" value="3" style="width:60px" />

      <label>Delay ms between batches</label>
      <input id="delayMs" value="600" style="width:80px" />

      <label>Body/Range ratio (max)</label>
      <input id="bodyRangeMax" value="0.25" style="width:80px" />

      <label>Body/Price pct (max)</label>
      <input id="bodyPriceMax" value="0.002" style="width:80px" />

      <button id="startTest">Start (test 6)</button>
      <button id="startAll">Start (all)</button>
      <button id="stop">Stop</button>
    </div>

    <div class="meta">
      <div class="summary">This tool checks the previous closed 1D candle (via REST klines) for a doji using two thresholds you can tweak: <em>bodyRangeMax</em> = max(body / (high-low)) and <em>bodyPriceMax</em> = max(body / meanPrice. Processing is throttled to stay safe for Binance rate limits.</div>
      <div style="margin-top:6px" id="info" class="small">Loaded — click Start (test 6) to verify quickly.</div>
    </div>

    <div class="log" id="log"></div>
    <div id="results"></div>
  </div>

<script>
(function(){
  const logEl = document.getElementById('log');
  const resultsEl = document.getElementById('results');
  const infoEl = document.getElementById('info');

  let running = false;
  let abortRequested = false;

  function now(){ return new Date().toLocaleTimeString(); }
  function uiLog(msg, err=false){
    const div = document.createElement('div');
    div.innerHTML = `<span class="small">[${now()}]</span> ${msg}`;
    if(err) div.style.color = '#ff9b9b';
    logEl.prepend(div);
    while(logEl.childNodes.length > 400) logEl.removeChild(logEl.lastChild);
    console.log(msg);
  }
  function showResult(text, isDoji){
    const el = document.createElement('div');
    el.className = 'result ' + (isDoji ? 'doji' : 'no');
    el.textContent = `${now()} — ${text}`;
    resultsEl.prepend(el);
    while(resultsEl.childNodes.length > 500) resultsEl.removeChild(resultsEl.lastChild);
  }

  // Fetch list of USDT perpetual symbols from exchange info
  async function fetchPerpSymbols(){
    const url = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
    uiLog('Fetching exchangeInfo...');
    const resp = await fetch(url);
    if(!resp.ok) throw new Error('exchangeInfo fetch failed: ' + resp.status);
    const json = await resp.json();
    const syms = json.symbols.filter(s => {
      const isUSDT = s.symbol && s.symbol.toUpperCase().endsWith('USDT');
      const isPerp = (s.contractType && s.contractType.toUpperCase()==='PERPETUAL') || (s.contractType === undefined && s.symbol && s.symbol.toUpperCase().endsWith('USDT'));
      return isUSDT && isPerp;
    }).map(s => s.symbol.toUpperCase());
    return syms;
  }

  // Fetch last N daily klines for a symbol; returns array of [openTime, open, high, low, close, ...]
  async function fetchDailyKlines(symbol, limit=3){
    const base = 'https://fapi.binance.com/fapi/v1/klines';
    const params = `?symbol=${encodeURIComponent(symbol)}&interval=1d&limit=${limit}`;
    const resp = await fetch(base + params);
    if(!resp.ok) throw new Error(`klines fetch failed ${symbol}: ${resp.status}`);
    const json = await resp.json();
    // each item: [ openTime, open, high, low, close, volume, closeTime, ... ]
    return json;
  }

  // doji detection logic for a single closed daily candle array item
  // Returns {isDoji, details}
  function isDojiFromKline(kline, bodyRangeMax, bodyPriceMax){
    // kline: [openTime, open, high, low, close, volume, closeTime, ...]
    const open = parseFloat(kline[1]);
    const high = parseFloat(kline[2]);
    const low = parseFloat(kline[3]);
    const close = parseFloat(kline[4]);
    const meanPrice = (high + low + close + open)/4;

    const body = Math.abs(close - open);
    const range = high - low || 1e-12;
    const bodyRangeRatio = body / range;
    const bodyPricePct = body / meanPrice;

    // small body relative to full range AND small in absolute price percent
    const isDoji = (bodyRangeRatio <= bodyRangeMax) && (bodyPricePct <= bodyPriceMax);

    return { isDoji, body, range, bodyRangeRatio, bodyPricePct, open, high, low, close, meanPrice };
  }

  // Process symbols in batches with concurrency and delay to respect limits.
  async function processSymbols(symbols, options){
    const {
      batchSize = 30,
      concurrency = 3,
      delayMs = 600,
      bodyRangeMax = 0.25,
      bodyPriceMax = 0.002,
      testMode = false
    } = options;

    // if testMode, reduce payload
    if(testMode) symbols = symbols.slice(0, 6);

    uiLog(`Processing ${symbols.length} symbols (batch ${batchSize}, concurrency ${concurrency}, delay ${delayMs}ms)`);

    // split into batches of batchSize
    const batches = [];
    for(let i=0;i<symbols.length;i+=batchSize) batches.push(symbols.slice(i, i+batchSize));

    // queue batches and process with concurrency
    let active = 0;
    let idx = 0;
    abortRequested = false;

    return new Promise((resolve) => {
      async function next(){
        if(abortRequested){
          uiLog('Abort requested — stopping processing.', true);
          return resolve();
        }
        if(idx >= batches.length && active === 0){
          uiLog('All batches processed.');
          return resolve();
        }
        while(active < concurrency && idx < batches.length){
          const batch = batches[idx++];
          active++;
          (async (batchSymbols, batchIndex) => {
            try{
              uiLog(`Batch ${batchIndex+1}/${batches.length}: ${batchSymbols.length} symbols — fetching klines...`);
              // process each symbol in this batch sequentially (safer for weight)
              for(const sym of batchSymbols){
                if(abortRequested) break;
                try{
                  const klines = await fetchDailyKlines(sym, 3);
                  // we want the previous closed candle: last closed is klines[klines.length-2] if last is current in-progress (unlikely for 1d if today not closed)
                  // Klines returned are closed candles; for safety we'll pick second-last if length>=2 else last
                  let closedIdx = klines.length - 2;
                  if(closedIdx < 0) closedIdx = klines.length - 1;
                  const prev = klines[closedIdx];
                  const res = isDojiFromKline(prev, bodyRangeMax, bodyPriceMax);
                  if(res.isDoji){
                    showResult(`${sym} — DOJI prev day. open=${res.open} close=${res.close} body=${res.body.toFixed(6)} range=${res.range.toFixed(6)} body/range=${res.bodyRangeRatio.toFixed(3)} body/price=${(res.bodyPricePct*100).toFixed(3)}%`, true);
                  } else {
                    // only log summarized non-doji to avoid noise
                    uiLog(`${sym} — not doji (body/range:${res.bodyRangeRatio.toFixed(3)}, body/price:${(res.bodyPricePct*100).toFixed(3)}%)`);
                  }
                }catch(errSym){
                  uiLog(`Error fetching ${sym}: ${errSym.message||errSym}`, true);
                }
                // tiny pause between symbol REST calls inside batch to spread the requests
                await new Promise(r => setTimeout(r, Math.max(40, Math.floor(delayMs / Math.max(1, batchSymbols.length)))));
              }

            }catch(errBatch){
              uiLog(`Batch ${batchIndex+1} failed: ${errBatch.message||errBatch}`, true);
            } finally {
              active--;
              // wait a small delay after batch to avoid bursts when opening next
              await new Promise(r => setTimeout(r, delayMs));
              next();
            }
          })(batch, idx-1);
        }
      }
      next();
    });
  }

  async function startTest(){
    if(running){ uiLog('Already running. Stop first.', true); return; }
    running = true;
    uiLog('Starting TEST (first 6 symbols) doji scan...');
    try{
      const syms = await fetchPerpSymbols();
      uiLog(`Got ${syms.length} symbols. Running test on first 6.`);
      const options = {
        batchSize: 6,
        concurrency: 1,
        delayMs: 400,
        bodyRangeMax: parseFloat(document.getElementById('bodyRangeMax').value) || 0.25,
        bodyPriceMax: parseFloat(document.getElementById('bodyPriceMax').value) || 0.002,
        testMode: true
      };
      await processSymbols(syms, options);
    }catch(err){
      uiLog('Failed to run test: ' + (err.message||err), true);
    } finally { running=false; uiLog('Test finished.'); }
  }

  async function startAll(){
    if(running){ uiLog('Already running. Stop first.', true); return; }
    running = true;
    uiLog('Starting FULL doji scan across USDT perpetuals...');
    try{
      const syms = await fetchPerpSymbols();
      uiLog(`Found ${syms.length} symbols. Beginning scan...`);
      const options = {
        batchSize: Math.max(8, parseInt(document.getElementById('batchSize').value) || 30),
        concurrency: Math.max(1, parseInt(document.getElementById('concurrency').value) || 3),
        delayMs: Math.max(200, parseInt(document.getElementById('delayMs').value) || 600),
        bodyRangeMax: parseFloat(document.getElementById('bodyRangeMax').value) || 0.25,
        bodyPriceMax: parseFloat(document.getElementById('bodyPriceMax').value) || 0.002,
        testMode: false
      };
      await processSymbols(syms, options);
    }catch(err){
      uiLog('Failed to run full scan: ' + (err.message||err), true);
    } finally { running=false; uiLog('Full scan finished.'); }
  }

  function stop(){
    abortRequested = true;
    running = false;
    uiLog('Stop requested. Current REST calls will finish then scanning will halt.');
  }

  document.getElementById('startTest').onclick = startTest;
  document.getElementById('startAll').onclick = startAll;
  document.getElementById('stop').onclick = stop;

  uiLog('Loaded. Use "Start (test 6)" to verify behavior quickly. Adjust thresholds (bodyRangeMax, bodyPriceMax) if you want looser/tighter doji detection.');
})();
</script>
</body>
</html>
