<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binance USDT-Perp Market Psychology Detector</title>
  <style>
    body{font-family:Inter,system-ui,Arial; background:#0f1720;color:#e6eef8;margin:12px}
    .card{background:#081028;border-radius:8px;padding:12px;margin:8px 0}
    table{width:100%;border-collapse:collapse}
    th,td{padding:6px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:left;font-size:13px}
    th{opacity:0.8}
    .chip{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px}
    .acc{background:#083f1f;color:#a8f0bb}
    .dist{background:#4a0f0f;color:#ffc6c6}
    .markup{background:#08305a;color:#bcd7ff}
    .markdown{background:#3a2a00;color:#ffe9a3}
    .status{margin-top:8px;font-size:13px}
    input,select{padding:6px;margin-right:6px}
  </style>
</head>
<body>
  <h2>Binance USDT‑Perp Market Psychology Detector</h2>
  <div class="card">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>Timeframe:<select id="tf"><option>1m</option><option>5m</option><option>15m</option><option>1h</option><option>4h</option><option>1d</option></select></label>
      <label>Batch size (symbols / websocket):<input type="number" id="batchSize" value="40" min="5" max="120"/></label>
      <label>Klines to fetch for rules:<input type="number" id="lookback" value="100" min="20" max="2000"/></label>
      <button id="start">Start</button>
      <button id="stop">Stop</button>
    </div>
    <div class="status" id="status">Idle</div>
  </div>  <div class="card" id="controls" style="display:block">
    <div style="margin-bottom:8px">Detected symbols (<span id="count">0</span>)</div>
    <div style="max-height:60vh;overflow:auto">
      <table id="table"><thead><tr><th>Symbol</th><th>Price</th><th>Phase</th><th>Reason</th></tr></thead><tbody></tbody></table>
    </div>
  </div>  <script>
  // This single-file demo shows a *safe-by-default* strategy to watch ALL USDT perpetual pairs
  // without hammering Binance rate limits:
  // 1) fetch /fapi/v1/exchangeInfo once (weight 1)
  // 2) build the list of symbols ending with USDT (futures perpetuals)
  // 3) for historical data (klines) we request in staggered batches with conservative LIMIT
  //    (use LIMIT <= 100 to keep request weight low)
  // 4) real-time updates via combined websocket streams, grouped into batches (batchSize)
  // 5) if any 429 or rate-limit headers seen, we back off with exponential delay
  // 6) a simple heuristic detects Accumulation / Distribution / Markup / Markdown
  //    - low volatility + sideways + rising volume => Accumulation
  //    - low volatility + sideways + falling volume => Distribution
  //    - trending up with momentum => Markup
  //    - trending down with momentum => Markdown
  // Note: This is a front-end prototype. For production use, server-side aggregation + API keys may be required.

  const API_BASE = 'https://fapi.binance.com';
  let running = false;
  let symbols = [];
  let sockets = [];
  let state = {};

  function setStatus(s){ document.getElementById('status').innerText = s }

  async function fetchExchangeInfo(){
    setStatus('Fetching exchange info...')
    const resp = await fetch(API_BASE + '/fapi/v1/exchangeInfo');
    if(!resp.ok) throw new Error('exchangeInfo failed: '+resp.status);
    const js = await resp.json();
    // filter USDT perpetual symbols: in futures exchangeInfo, symbols with quoteAsset 'USDT' are usually USDT-M
    const usdt = js.symbols.filter(s=>s.contractType && (s.symbol.endsWith('USDT') || s.quoteAsset==='USDT'))
    return usdt.map(s=>s.symbol)
  }

  // small indicator library
  function sma(arr, n){ if(arr.length<n) return null; const slice=arr.slice(-n); return slice.reduce((a,b)=>a+b,0)/n }
  function stddev(arr, n){ if(arr.length<n) return null; const slice=arr.slice(-n); const m=sma(slice,n); const v=slice.reduce((a,b)=>a+Math.pow(b-m,2),0)/n; return Math.sqrt(v) }
  function atr(highs,lows,closes,n=14){ if(closes.length<n) return null; let trs=[]; for(let i=1;i<closes.length;i++){ const tr=Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1])); trs.push(tr) } let sum=trs.slice(-n).reduce((a,b)=>a+b,0); return sum/n }

  // simple psychology detector
  function detectPhase(klines, volumes){
    // klines: array of close prices (number)
    if(klines.length<30) return {phase:'unknown',reason:'insufficient data'}
    const closes = klines.map(k=>k[4]); // close price
    const highs = klines.map(k=>k[2]);
    const lows = klines.map(k=>k[3]);
    const vols = volumes || klines.map(k=>k[5]);
    const sma20 = sma(closes,20);
    const sma50 = sma(closes,50);
    const volRecent = sma(vols,5);
    const volPast = sma(vols,30);
    const sd20 = stddev(closes,20);
    const atr14 = atr(highs,lows,closes,14);
    const last = parseFloat(closes[closes.length-1]);
    const prev = parseFloat(closes[closes.length-6]);
    const slope = (last - prev)/prev;

    // compression: low volatility relative to price
    const compression = (atr14 && (atr14/last) < 0.006) || (sd20 && (sd20/last) < 0.004);
    const volRising = volRecent && volPast && (volRecent > volPast*1.15);
    const volFalling = volRecent && volPast && (volRecent < volPast*0.85);

    if(compression && volRising && slope>0) return {phase:'Accumulation','reason':'low volatility + volume rising + slight upward bias'}
    if(compression && volFalling && slope<=0) return {phase:'Distribution','reason':'low volatility + volume falling + no upward bias'}
    if(slope>0.02 || (sma20 && sma50 && sma20> s ma50)) return {phase:'Markup','reason':'strong upward momentum'}
    if(slope<-0.02 || (sma20 && sma50 && sma20< s ma50)) return {phase:'Markdown','reason':'strong downward momentum'}

    // fallback: look at trend relative to sma50
    if(sma20 && sma50){
      if(sma20 > sma50) return {phase:'Markup','reason':'price above mid-term average'}
      if(sma20 < sma50) return {phase:'Markdown','reason':'price below mid-term average'}
    }

    return {phase:'Sideways','reason':'no clear momentum or compression signals'}
  }

  // SAFE fetch for klines with throttling and backoff
  async function safeFetchKlines(symbol, interval, limit=100){
    const url = `${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
    let tries=0;
    while(tries<5){
      try{
        const resp = await fetch(url);
        if(resp.status===429 || resp.status===418){
          const wait = (Math.pow(2,tries)+1)*1000;
          console.warn('rate limited, backing off',wait);
          await new Promise(r=>setTimeout(r,wait));
          tries++; continue;
        }
        if(!resp.ok) throw new Error('klines failed:'+resp.status);
        return await resp.json();
      }catch(e){
        console.error('klines fetch error',e);
        const wait = (Math.pow(2,tries)+1)*1000;
        await new Promise(r=>setTimeout(r,wait));
        tries++;
      }
    }
    throw new Error('klines fetch failed after retries');
  }

  function addRow(symbol, price, phase, reason){
    const tbody = document.querySelector('#table tbody');
    let row = document.getElementById('r-'+symbol);
    if(!row){ row = document.createElement('tr'); row.id = 'r-'+symbol; row.innerHTML = `<td>${symbol}</td><td class="price"></td><td class="phase"></td><td class="reason"></td>`; tbody.appendChild(row); }
    row.querySelector('.price').innerText = price;
    const pcell = row.querySelector('.phase');
    pcell.innerText = phase;
    pcell.className = 'phase chip ' + (phase.toLowerCase());
    row.querySelector('.reason').innerText = reason;
  }

  async function start(){
    if(running) return; running=true; setStatus('Starting...');
    const tf = document.getElementById('tf').value;
    const batchSize = parseInt(document.getElementById('batchSize').value,10)||40;
    const lookback = parseInt(document.getElementById('lookback').value,10)||100;

    symbols = await fetchExchangeInfo();
    document.getElementById('count').innerText = symbols.length;
    setStatus('Got '+symbols.length+' symbols. Preparing batches...');

    // build batches
    const batches = [];
    for(let i=0;i<symbols.length;i+=batchSize) batches.push(symbols.slice(i,i+batchSize));

    // for each symbol fetch historical klines but stagger the requests (conservative)
    setStatus('Fetching historical klines (staggered). This may take some time depending on symbol count.');
    for(let i=0;i<symbols.length;i++){
      const sym = symbols[i];
      try{
        // stagger 200ms per symbol (very conservative). You can increase concurrency with a server-side worker.
        await new Promise(r=>setTimeout(r,200));
        const klines = await safeFetchKlines(sym, tf, Math.min(lookback,100));
        const det = detectPhase(klines);
        const price = klines[klines.length-1][4];
        state[sym] = {klines,phase:det.phase,reason:det.reason,price};
        addRow(sym,price,det.phase,det.reason);
      }catch(e){ console.warn('hist fail',sym,e); addRow(sym,'-','error','history fetch failed') }
    }

    setStatus('Connecting websockets in '+batches.length+' batches...');

    // for real-time, open combined streams per batch
    for(let b=0;b<batches.length;b++){
      const list = batches[b];
      // build stream path like btcusdt@kline_1m/ethusdt@kline_1m
      const streams = list.map(s=>s.toLowerCase()+'@kline_'+tf).join('/');
      const url = `wss://fstream.binance.com/stream?streams=${streams}`;
      // delay between opening connections to avoid connection storms
      await new Promise(r=>setTimeout(r,500*(b%3+1)));
      const ws = new WebSocket(url);
      sockets.push(ws);
      ws.onopen = ()=>console.log('ws open',b,list.length);
      ws.onmessage = (ev)=>{
        const data = JSON.parse(ev.data);
        // combined stream returns {stream, data}
        const payload = data.data || data;
        if(payload && payload.k){
          const k = payload.k; // kline object
          const sym = k.s;
          const close = k.c;
          // update stored klines (keep max lookback)
          if(state[sym] && state[sym].klines){
            state[sym].klines.push([k.t,k.o,k.h,k.l,k.c,k.v]);
            if(state[sym].klines.length>200) state[sym].klines.shift();
            const det = detectPhase(state[sym].klines);
            state[sym].phase = det.phase; state[sym].reason = det.reason; state[sym].price = close;
            addRow(sym,close,det.phase,det.reason);
          }
        }
      }
      ws.onerror = (e)=>console.warn('ws err',e);
      ws.onclose = ()=>console.log('ws closed',b);
    }

    setStatus('Running — live updates active. Watch the table.')
  }

  function stop(){ running=false; setStatus('Stopping — closing sockets'); sockets.forEach(s=>s.close()); sockets=[] }

  document.getElementById('start').addEventListener('click', ()=>start().catch(e=>setStatus('Error: '+e.message)));
  document.getElementById('stop').addEventListener('click', ()=>stop());
  </script></body>
</html>
