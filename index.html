<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Perp Consolidation Detector — Binance Futures (USDT) </title>
  <style>
    body{font-family:Inter, Roboto, Arial; background:#0f1720; color:#e6eef8; margin:12px}
    .card{background:#0b1220;border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,0.5);max-width:980px}
    label,input,button,select{font-size:14px}
    input,select{padding:6px;margin-right:6px;background:#071021;border:1px solid #172033;color:#d6e7ff;border-radius:6px}
    button{padding:8px 10px;border-radius:8px;border:none;background:#1f8cff;color:#fff}
    .log{background:#06121a;padding:8px;border-radius:6px;margin-top:10px;min-height:120px;overflow:auto}
    .signal{padding:8px;border-radius:6px;margin-top:8px}
    .signal.ok{background:#08331a;color:#a6f7be}
    .signal.warn{background:#3a2a0f;color:#ffd9a5}
    .signal.bad{background:#3a0f0f;color:#ffbdbd}
    .status{margin-left:8px;font-size:13px;color:#94a3b8}
    .row{display:flex;align-items:center;gap:6px}
  </style>
</head>
<body>
  <div class="card">
    <h2>Perp Consolidation & Breakout Detector (HTML)</h2>
    <p>Connects to Binance Futures WebSocket for <strong>symbol</strong> + <strong>interval</strong>, detects consolidation (buying zone) and signals breakout with volume confirmation.</p><div class="row">
  <label>Symbol</label>
  <input id="symbol" value="btcusdt" />
  <label>Interval</label>
  <select id="interval">
    <option value="1m">1m</option>
    <option value="3m">3m</option>
    <option value="5m" selected>5m</option>
    <option value="15m">15m</option>
    <option value="1h">1h</option>
  </select>
  <label>Lookback candles</label>
  <input id="lookback" value="24" style="width:64px" />
  <label>Consol STD thresh</label>
  <input id="stdTh" value="0.004" style="width:80px" />
  <button id="start">Start</button>
  <button id="stop">Stop</button>
</div>

<div style="margin-top:10px">
  <strong>How it works (defaults):</strong>
  <ul>
    <li>Collects `lookback` kline candles (close, high, low, volume).</li>
    <li>Consolidation detected when close-price std dev relative to mean &lt; <code>stdTh</code> and ATR is small and EMA spread compressed.</li>
    <li>Breakout confirmed when price closes above consolidation resistance and volume &gt; volumeMA * 1.5.</li>
  </ul>
</div>

<div class="log" id="log"></div>
<div id="signals"></div>

  </div><script>
// --- IMPORTANT NOTES ---
// 1) This demo uses Binance Futures websocket: wss://fstream.binance.com/ws/{symbol}@kline_{interval}
//    Use lowercase symbol like btcusdt, ethusdt, etc.
// 2) For reliability & to respect Binance rate limits: prefer WebSocket streams over frequent REST polling.
// 3) Subscribe to only the symbols you need. If you want many symbols, batch and throttle subscriptions.
// 4) This is a browser-only demo. For production, move logic to a server with proper reconnect/backoff, signature auth (if needed), and rate-limit handling.

(function(){
  const logEl = document.getElementById('log');
  const signalsEl = document.getElementById('signals');
  let ws = null;
  let running = false;

  function log(msg){
    const now = new Date().toLocaleTimeString();
    logEl.innerHTML = `<div>[${now}] ${msg}</div>` + logEl.innerHTML;
  }

  function setSignal(msg, level='ok'){
    const el = document.createElement('div');
    el.className = `signal ${level}`;
    el.textContent = `${new Date().toLocaleTimeString()} — ${msg}`;
    signalsEl.prepend(el);
  }

  // Simple EMA helper
  function ema(values, period){
    if(values.length===0) return null;
    const k = 2/(period+1);
    let emaPrev = values[0];
    for(let i=1;i<values.length;i++) emaPrev = values[i]*k + emaPrev*(1-k);
    return emaPrev;
  }

  // ATR using highs/lows/closes
  function atr(candles, period=14){
    if(candles.length<=1) return 0;
    let trs=[];
    for(let i=1;i<candles.length;i++){
      const high = parseFloat(candles[i].h);
      const low = parseFloat(candles[i].l);
      const prevClose = parseFloat(candles[i-1].c);
      const tr = Math.max(high-low, Math.abs(high-prevClose), Math.abs(low-prevClose));
      trs.push(tr);
    }
    if(trs.length === 0) return 0;
    // simple average of last `period` TRs
    const sub = trs.slice(-period);
    return sub.reduce((a,b)=>a+b,0)/sub.length;
  }

  // detect consolidation
  function detectConsolidation(candles, stdTh=0.004){
    // use close prices
    const closes = candles.map(c=>parseFloat(c.c));
    const mean = closes.reduce((a,b)=>a+b,0)/closes.length;
    const diffs = closes.map(v=>v-mean);
    const variance = diffs.reduce((a,b)=>a+b*b,0)/closes.length;
    const std = Math.sqrt(variance);
    const relativeStd = std/mean; // fraction of price

    // ATR relative to mean
    const myAtr = atr(candles, Math.min(14, candles.length-1));
    const relativeAtr = myAtr/mean;

    // EMA spread: use short & long
    const shortE = ema(closes.slice(-10), 5);
    const longE = ema(closes.slice(-20), 10) || shortE;
    const emaSpread = Math.abs(shortE-longE)/mean;

    // determine threshold rules - tweakable
    const isStdTight = relativeStd < stdTh;            // low std dev
    const isAtrLow = relativeAtr < Math.max(stdTh*1.5, 0.005); // ATR small
    const isEmaCompressed = emaSpread < stdTh*1.5;

    return {
      consolidation: isStdTight && isAtrLow && isEmaCompressed,
      relativeStd, relativeAtr, emaSpread, mean, std
    };
  }

  // determine resistance/top of range and support
  function rangeFromCandles(candles){
    const highs = candles.map(c=>parseFloat(c.h));
    const lows = candles.map(c=>parseFloat(c.l));
    return {res: Math.max(...highs), sup: Math.min(...lows)};
  }

  // volume MA
  function volMA(candles, n=20){
    const vols = candles.map(c=>parseFloat(c.v));
    const sub = vols.slice(-n);
    return sub.reduce((a,b)=>a+b,0)/sub.length;
  }

  // connect
  function start(){
    if(running) return;
    const symbol = (document.getElementById('symbol').value || 'btcusdt').toLowerCase();
    const interval = document.getElementById('interval').value || '5m';
    const lookback = parseInt(document.getElementById('lookback').value)||24;
    const stdTh = parseFloat(document.getElementById('stdTh').value)||0.004;

    running = true;
    log(`Starting detector for ${symbol}@${interval} (lookback ${lookback})`);

    // wss stream
    const wsUrl = `wss://fstream.binance.com/ws/${symbol}@kline_${interval}`;
    ws = new WebSocket(wsUrl);

    const candles = []; // store recent candles (kline.c, kline.h, kline.l, kline.v)

    ws.onopen = ()=> log('WS OPEN');
    ws.onclose = ()=> { log('WS CLOSED'); running=false; };
    ws.onerror = (e)=> log('WS ERROR ' + JSON.stringify(e));

    ws.onmessage = (evt)=>{
      try{
        const d = JSON.parse(evt.data);
        if(!d.k) return; // not kline
        const k = d.k;
        const candle = {t:k.t, o:k.o, h:k.h, l:k.l, c:k.c, v:k.v, isFinal:k.x};

        // push or update last
        if(candles.length===0 || candles[candles.length-1].t !== candle.t) {
          candles.push(candle);
          if(candles.length>200) candles.shift();
        } else {
          candles[candles.length-1] = candle; // update in-progress candle
        }

        // only analyze on closed candles for conservative signals
        if(!candle.isFinal) return;

        // need lookback candles
        if(candles.length < lookback) {
          log(`collected ${candles.length}/${lookback} candles`);
          return;
        }

        // take last lookback candles
        const recent = candles.slice(-lookback);
        const cons = detectConsolidation(recent, stdTh);
        const r = rangeFromCandles(recent);
        const vMA = volMA(candles, Math.min(40, candles.length));
        const lastClose = parseFloat(candle.c);
        const lastVol = parseFloat(candle.v);

        log(`analyze: std=${cons.relativeStd.toFixed(5)} atr=${cons.relativeAtr.toFixed(5)} emaSpread=${cons.emaSpread.toFixed(5)}`);

        if(cons.consolidation){
          setSignal(`Consolidation detected. Range ${r.sup.toFixed(6)} - ${r.res.toFixed(6)}. mean=${cons.mean.toFixed(6)}`,'warn');
          // store this consolidation snapshot in localStorage (optional) for later retest
          localStorage.setItem('lastConsol_'+symbol, JSON.stringify({time:Date.now(), range:r, mean:cons.mean}));
        }

        // breakout rule: the current closed candle close > range.res * (1 + small buffer) and volume confirmation
        const breakoutBuffer = 0.0005; // 0.05% buffer; tweak per-symbol
        const isBreakout = lastClose > r.res*(1+breakoutBuffer);
        const volConfirm = lastVol > Math.max(1.2*vMA, vMA + vMA*0.05);

        if(isBreakout && volConfirm){
          setSignal(`Breakout confirmed! Close ${lastClose.toFixed(6)} > resistance ${r.res.toFixed(6)} with volume ${lastVol.toFixed(0)} (vMA ${Math.round(vMA)})`,'ok');
          // recommended action: alert or push to server side order engine. For safety, do NOT auto-trade from this demo.
        } else if(isBreakout && !volConfirm){
          setSignal(`Potential breakout (price). Volume not strong enough. lastVol ${Math.round(lastVol)} vMA ${Math.round(vMA)}`,'warn');
        }

      }catch(e){ console.error(e); }
    };

    // reconnect/backoff: very simple
    ws.onclose = ()=>{
      log('WS closed, will stop. For production implement exponential backoff and resume.');
      running=false;
    };
  }

  function stop(){
    if(ws) ws.close();
    running=false;
    log('Stopped');
  }

  document.getElementById('start').onclick = start;
  document.getElementById('stop').onclick = stop;
})();
</script></body>
</html>
