<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Perp Consolidation Detector — All USDT Perpetuals</title>
  <style>
    body{font-family:Inter, Roboto, Arial; background:#0f1720; color:#e6eef8; margin:12px}
    .card{background:#0b1220;border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,0.5);max-width:1200px}
    label,input,button,select{font-size:14px}
    input,select{padding:6px;margin-right:6px;background:#071021;border:1px solid #172033;color:#d6e7ff;border-radius:6px}
    button{padding:8px 10px;border-radius:8px;border:none;background:#1f8cff;color:#fff;cursor:pointer}
    .log{background:#06121a;padding:8px;border-radius:6px;margin-top:10px;min-height:160px;overflow:auto}
    .signal{padding:8px;border-radius:6px;margin-top:8px}
    .signal.ok{background:#08331a;color:#a6f7be}
    .signal.warn{background:#3a2a0f;color:#ffd9a5}
    .signal.bad{background:#3a0f0f;color:#ffbdbd}
    .row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
    .meta{margin-top:8px;color:#94a3b8;font-size:13px}
    .status-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
    .status-running{background:#22c55e}
    .status-stopped{background:#ef4444}
    .status-idle{background:#94a3b8}
    .small{font-size:12px;color:#9fb5d6}
    .summary{margin-top:8px;color:#9fb5d6;font-size:13px}
  </style>
</head>
<body>
  <div class="card">
    <h2>Perp Consolidation & Breakout Detector — All USDT Perpetuals (Demo)</h2>

    <div class="row">
      <label>Interval</label>
      <select id="interval">
        <option value="1m">1m</option>
        <option value="3m">3m</option>
        <option value="5m" selected>5m</option>
        <option value="15m">15m</option>
        <option value="1h">1h</option>
      </select>

      <label>Lookback</label>
      <input id="lookback" value="24" style="width:64px" />

      <label>StdTh</label>
      <input id="stdTh" value="0.004" style="width:80px" />

      <label>Batch size</label>
      <input id="batchSize" value="60" style="width:64px" />

      <button id="start">Start (all USDT perp)</button>
      <button id="stop">Stop</button>
    </div>

    <div class="meta">
      <div class="summary">
        This demo will fetch the Binance futures exchange info, find symbols that are USDT perpetual contracts, then open combined websocket streams in batches.
      </div>
      <div style="margin-top:6px">
        <span id="info" class="small"></span>
      </div>
    </div>

    <div class="log" id="log"></div>
    <div id="signals"></div>
  </div>

<script>
(function(){
  const logEl = document.getElementById('log');
  const signalsEl = document.getElementById('signals');
  const infoEl = document.getElementById('info');
  let connections = []; // {ws, batchSymbols, url}
  let running = false;
  let allSymbols = [];

  function now(){ return new Date().toLocaleTimeString(); }
  function uiLog(msg){ logEl.innerHTML = `<div>[${now()}] ${msg}</div>` + logEl.innerHTML; console.log(msg); }
  function setSignal(msg, level='ok'){ const el=document.createElement('div'); el.className=`signal ${level}`; el.textContent=`${now()} — ${msg}`; signalsEl.prepend(el); console.log('signal', level, msg); }

  // small indicators & analysis functions (same as earlier)
  function ema(values, period){
    if(!Array.isArray(values) || values.length===0) return null;
    const k = 2/(period+1);
    let emaPrev = values[0];
    for(let i=1;i<values.length;i++) emaPrev = values[i]*k + emaPrev*(1-k);
    return emaPrev;
  }
  function atr(candles, period=14){
    if(!candles || candles.length<=1) return 0;
    let trs=[];
    for(let i=1;i<candles.length;i++){
      const high = parseFloat(candles[i].h);
      const low = parseFloat(candles[i].l);
      const prevClose = parseFloat(candles[i-1].c);
      const tr = Math.max(high-low, Math.abs(high-prevClose), Math.abs(low-prevClose));
      trs.push(tr);
    }
    if(trs.length === 0) return 0;
    const sub = trs.slice(-period);
    return sub.reduce((a,b)=>a+b,0)/sub.length;
  }
  function detectConsolidation(candles, stdTh=0.004){
    const closes = candles.map(c=>parseFloat(c.c));
    const mean = closes.reduce((a,b)=>a+b,0)/closes.length;
    const diffs = closes.map(v=>v-mean);
    const variance = diffs.reduce((a,b)=>a+b*b,0)/closes.length;
    const std = Math.sqrt(variance);
    const relativeStd = std/mean;
    const myAtr = atr(candles, Math.min(14, candles.length-1));
    const relativeAtr = myAtr/mean;
    const shortE = ema(closes.slice(-10), 5);
    const longE = ema(closes.slice(-20), 10) || shortE;
    const emaSpread = Math.abs(shortE-longE)/mean;
    const isStdTight = relativeStd < stdTh;
    const isAtrLow = relativeAtr < Math.max(stdTh*1.5, 0.005);
    const isEmaCompressed = emaSpread < stdTh*1.5;
    return { consolidation: isStdTight && isAtrLow && isEmaCompressed, relativeStd, relativeAtr, emaSpread, mean, std };
  }
  function rangeFromCandles(candles){ const highs=candles.map(c=>parseFloat(c.h)); const lows=candles.map(c=>parseFloat(c.l)); return {res:Math.max(...highs), sup:Math.min(...lows)}; }
  function volMA(candles, n=20){ if(!candles || candles.length===0) return 0; const vols=candles.map(c=>parseFloat(c.v)); const sub=vols.slice(-n); return sub.reduce((a,b)=>a+b,0)/sub.length; }

  // fetch exchange info and filter perp USDT symbols
  async function fetchPerpSymbols(){
    const url = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
    uiLog('Fetching exchange info from Binance...');
    const resp = await fetch(url);
    if(!resp.ok) throw new Error('exchangeInfo fetch failed: ' + resp.status);
    const json = await resp.json();
    // filter symbols: contractType PERPETUAL; symbol endsWith USDT
    // NOTE: exchangeInfo for futures contains contracts entries under symbols array, with contractType property for each symbol
    const syms = json.symbols.filter(s => {
      // For Binance futures exchangeInfo, `symbol` typically present. There may also be `contractType` in the query param; if not, fallback to naming convention
      const isUSDT = s.symbol && s.symbol.toUpperCase().endsWith('USDT');
      const isPerp = (s.contractType && s.contractType.toUpperCase()==='PERPETUAL') || (s.contractType === undefined && s.symbol && s.symbol.toUpperCase().endsWith('USDT'));
      return isUSDT && isPerp;
    }).map(s => s.symbol.toLowerCase());
    return syms;
  }

  // split into batches
  function splitBatches(arr, size){
    const out=[];
    for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i,i+size));
    return out;
  }

  // create combined ws for a batch of symbols for the selected interval
  function createWsForBatch(symbolBatch, interval, stdTh, lookback){
    // build streams like btcusdt@kline_1m/ethusdt@kline_1m
    const streamNames = symbolBatch.map(s => `${s}@kline_${interval}`).join('/');
    const url = `wss://fstream.binance.com/stream?streams=${streamNames}`;
    uiLog(`Opening WS for batch (${symbolBatch.length}) ...`);
    const ws = new WebSocket(url);
    const candleStores = {}; // symbol -> list of recent candles
    ws.onopen = ()=> uiLog(`WS OPEN (batch size ${symbolBatch.length})`);
    ws.onerror = (e)=> uiLog('WS ERROR (batch) - check console');
    ws.onclose = (ev)=> uiLog(`WS CLOSED (batch). code=${ev.code}`);
    ws.onmessage = (evt)=>{
      try{
        const d = JSON.parse(evt.data);
        // combined stream message shape: {stream: 'btcusdt@kline_5m', data: {k: {...}}}
        const stream = d.stream;
        const payload = d.data;
        if(!payload || !payload.k) return;
        const k = payload.k;
        const sym = (stream.split('@')[0]).toLowerCase();
        const candle = {t:k.t, o:k.o, h:k.h, l:k.l, c:k.c, v:k.v, isFinal:k.x};
        if(!candleStores[sym]) candleStores[sym] = [];
        const store = candleStores[sym];
        if(store.length===0 || store[store.length-1].t !== candle.t){
          store.push(candle);
          if(store.length>500) store.shift();
        } else {
          store[store.length-1] = candle;
        }
        if(!candle.isFinal) return;
        if(store.length < lookback) return;
        const recent = store.slice(-lookback);
        const cons = detectConsolidation(recent, stdTh);
        const r = rangeFromCandles(recent);
        const vMA = volMA(store, Math.min(40, store.length));
        const lastClose = parseFloat(candle.c);
        const lastVol = parseFloat(candle.v);

        if(cons.consolidation){
          setSignal(`${sym.toUpperCase()} consolidation: ${r.sup.toFixed(6)} - ${r.res.toFixed(6)} (std:${cons.relativeStd.toFixed(6)})`,'warn');
          // optionally persist snapshot: localStorage.setItem(...)
        }

        const breakoutBuffer = 0.0005;
        const isBreakout = lastClose > r.res*(1+breakoutBuffer);
        const volConfirm = lastVol > Math.max(1.2*vMA, vMA + vMA*0.05);

        if(isBreakout && volConfirm){
          setSignal(`${sym.toUpperCase()} BREAKOUT confirmed. close ${lastClose.toFixed(6)} > ${r.res.toFixed(6)} vol ${Math.round(lastVol)}`,'ok');
        } else if(isBreakout && !volConfirm){
          setSignal(`${sym.toUpperCase()} breakout price but weak vol. lastVol ${Math.round(lastVol)} vMA ${Math.round(vMA)}`,'warn');
        }

      }catch(err){ console.error('batch message parse error', err); }
    };
    return {ws, url, batchSymbols: symbolBatch};
  }

  async function startAll(){
    if(running) { uiLog('Already running'); return; }
    uiLog('Starting full symbols detector...');
    setTimeout(()=>window.scrollTo(0,0), 100);
    try{
      allSymbols = await fetchPerpSymbols();
      if(!allSymbols || allSymbols.length===0) { uiLog('No symbols found.'); return; }
      uiLog(`Found ${allSymbols.length} USDT perpetual symbols (first 10): ${allSymbols.slice(0,10).map(s=>s.toUpperCase()).join(', ')}`);
      infoEl.textContent = `Found ${allSymbols.length} symbols.`;
    }catch(err){
      uiLog('Failed to fetch symbols: ' + err.message);
      return;
    }

    const interval = document.getElementById('interval').value || '5m';
    const lookback = parseInt(document.getElementById('lookback').value)||24;
    const stdTh = parseFloat(document.getElementById('stdTh').value)||0.004;
    const batchSize = Math.max(8, parseInt(document.getElementById('batchSize').value)||60); // avoid tiny batch

    const batches = splitBatches(allSymbols, batchSize);
    uiLog(`Creating ${batches.length} websocket connections (batchSize ${batchSize}).`);

    // close previous conns if any
    stopAll();

    // create all connections
    for(const batch of batches){
      try{
        const conn = createWsForBatch(batch, interval, stdTh, lookback);
        connections.push(conn);
      }catch(e){
        uiLog('Failed to open batch WS: ' + e.message);
      }
    }
    running = true;
    uiLog('All batch connections started. Monitor signals above.');
  }

  function stopAll(){
    running = false;
    for(const c of connections){
      try{ if(c.ws && c.ws.readyState === WebSocket.OPEN) c.ws.close(); }catch(e){}
    }
    connections = [];
    uiLog('Stopped all connections.');
  }

  document.getElementById('start').onclick = startAll;
  document.getElementById('stop').onclick = stopAll;

  uiLog('Loaded. Click Start to begin fetching & subscribing to all USDT perpetual symbols.');
})();
</script>
</body>
</html>
